# -*- coding: utf-8 -*-
"""DAMT_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qwxp2RIWOrHqjnqrGKATI1MUVnRffrw6
"""

import pandas as pd
import math
import pandas_datareader as pdr
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import numpy as np
import matplotlib.pyplot as plt
#plt.style.use('fivethirtyeight')

dq = pd.read_csv (r'add_file_path_here',index_col='Date',parse_dates=True)
print('Shape of data',dq.shape)
dq.head()

dq['Close_Moderna'].plot(figsize=(15,9),label = 'Moderna')
plt.title('PHARMACEUTICAL COMPANIES ')
plt.xlabel('DATE -->',fontsize = 20)
plt.ylabel('PRICE -->',fontsize = 20)
plt.legend()

databt = dq.filter(['Close_BioNtech'])

datanv = dq.filter(['Close_Novavax'])

datamd = dq.filter(['Close_Moderna'])

datainv = dq.filter(['Close_Inovio Pharmaceuticals'])
datasetbt = databt.values
datasetnv = datanv.values
datasetmd = datamd.values
datasetinv = datainv.values
len_training_databt = math.ceil(len(datasetbt))
len_training_datanv = math.ceil(len(datasetnv))
len_training_datamd = math.ceil(len(datasetmd))
len_training_datainv = math.ceil(len(datasetinv))

mms = MinMaxScaler(feature_range=(0,1))
scaled_datamd = mms.fit_transform(datamd)
scaled_datanv = mms.fit_transform(datanv)
scaled_datainv = mms.fit_transform(datainv)

train_datanv = scaled_datanv[0:len_training_datanv,:]
x_trainnv =[]
y_trainnv =[]
train_datainv = scaled_datainv[0:len_training_datainv,:]
x_traininv =[]
y_traininv =[]
train_datamd = scaled_datamd[0:len_training_datamd,:]
x_trainmd =[]
y_trainmd =[]

for i in range(90,len(train_datainv)):
  x_traininv.append(train_datainv[i-90:i,0])
  y_traininv.append(train_datainv[i,0])
  
for p in range(90,len(train_datamd)):
    x_trainmd.append(train_datamd[p-90:p,0])
    y_trainmd.append(train_datamd[p,0])
    
for q in range(90,len(train_datanv)):
  x_trainnv.append(train_datanv[q-90:q,0])
  y_trainnv.append(train_datanv[q,0])

test_datanv = scaled_datanv[len_training_datanv - 90: ,:]
x_testnv = []
y_testnv = datasetnv[len_training_datanv:, :]
for q in range(90,len(test_datanv)):
  x_testnv.append(test_datanv[q-90:q,0])

test_datainv = scaled_datainv[len_training_datainv-90: ,:]
x_testinv = []
y_testinv = datasetinv[len_training_datainv: ,:]
for i in range(90,len(test_datainv)):
  x_testinv.append(test_datainv[i-90:i,0])

test_datamd = scaled_datamd[len_training_datamd-90: ,:]
x_testmd = []
y_testmd = datasetmd[len_training_datamd: ,:]
for p in range(90,len(test_datamd)):
  x_testmd.append(test_datamd[p-90:p,0])

x_testnv = np.array(x_testnv)
x_testmd = np.array(x_testmd)
x_testinv = np.array(x_testinv)

x_trainnv,y_trainnv =np.array(x_trainnv),np.array(y_trainnv)
x_traininv,y_traininv =np.array(x_traininv),np.array(y_traininv)
x_trainmd,y_trainmd =np.array(x_trainmd),np.array(y_trainmd)

x_trainnv =np.reshape(x_trainnv,(x_trainnv.shape[0],x_trainnv.shape[1],1))
x_traininv =np.reshape(x_traininv,(x_traininv.shape[0],x_traininv.shape[1],1))
x_trainmd =np.reshape(x_trainmd,(x_trainmd.shape[0],x_trainmd.shape[1],1))
x_trainnv.shape

modelnv = Sequential()
modelnv.add(LSTM(90, return_sequences=True,input_shape=(x_trainnv.shape[1],1)))
modelnv.add(LSTM(90,return_sequences=False))
modelnv.add(Dense(25))
modelnv.add(Dense(1))
modelmd = Sequential()
modelmd.add(LSTM(90, return_sequences=True,input_shape=(x_trainmd.shape[1],1)))
modelmd.add(LSTM(90,return_sequences=False))
modelmd.add(Dense(25))
modelmd.add(Dense(1))
modelinv = Sequential()
modelinv.add(LSTM(90, return_sequences=True,input_shape=(x_traininv.shape[1],1)))
modelinv.add(LSTM(90,return_sequences=False))
modelinv.add(Dense(25))
modelinv.add(Dense(1))

modelnv.compile(optimizer='adam',loss='mean_squared_error')
modelinv.compile(optimizer='adam',loss='mean_squared_error')
modelmd.compile(optimizer='adam',loss='mean_squared_error')

modelnv.fit(x_trainnv,y_trainnv,batch_size=1,epochs=1)

modelinv.fit(x_traininv,y_traininv,batch_size=1,epochs=10)

modelmd.fit(x_trainmd,y_trainmd,batch_size=1,epochs=10)

predictionsmd = modelmd.predict(x_testmd)
predictionsmd = mms.inverse_transform(predictionsmd)
predictionsnv = modelnv.predict(x_testnv)
predictionsnv = mms.inverse_transform(predictionsnv)
predictionsinv = modelinv.predict(x_testinv)
predictionsinv = mms.inverse_transform(predictionsinv)

x_testmd=np.reshape(x_testmd,(x_testmd.shape[0],x_testmd.shape[1],1))

x_testnv=np.reshape(x_testnv,(x_testnv.shape[0],x_testnv.shape[1],1))
x_testinv=np.reshape(x_testinv,(x_testinv.shape[0],x_testinv.shape[1],1))
x_testmd

rmsemd=np.sqrt(np.mean(predictionsmd - y_testmd)**2)
rmsenv=np.sqrt(np.mean(predictionsnv - y_testnv)**2)
rmseinv=np.sqrt(np.mean(predictionsinv - y_testinv)**2)

trainpredictmd = datamd[:len_training_datamd]
testpredictmd = datamd[len_training_datamd:]
testpredictmd['predictionsmd'] = predictionsmd
trainpredictnv = datanv[:len_training_datanv]
testpredictnv = datanv[len_training_datanv:]
testpredictnv['predictionsnv'] = predictionsnv
trainpredictinv = datainv[:len_training_datainv]
testpredictinv = datainv[len_training_datainv:]
testpredictinv['predictionsinv'] = predictionsinv

plt.title('PREDICTIONS')
plt.xlabel('DATE -->',fontsize = 20)
plt.ylabel('PRICE -->',fontsize = 20)
plt.plot(trainpredictmd['Close_Moderna'])
plt.plot(trainpredictnv['Close_Novavax'])
plt.plot(trainpredictinv['Close_Inovio Pharmaceuticals'])
plt.plot(testpredictmd[['Close_Moderna','Predictionsmd']])
plt.plot(testpredictnv[['Close_Novavax','Predictionsnv']])
plt.plot(testpredictinv[['Close_Inovio Pharmaceuticals','Predictionsinv']])
plt.legend()

x_inputmd = test_datamd[31:].reshape(1,-1)
x_inputmd=list(x_inputmd)
temp_inputmd=temp_inputmd[0].tolist()
x_inputnv = test_datanv[31:].reshape(1,-1)
x_inputnv=list(x_inputnv)
temp_inputnv=temp_inputnv[0].tolist()
x_inputinv = test_datainv[31:].reshape(1,-1)
x_inputinv=list(x_inputinv)
temp_inputinv=temp_inputinv[0].tolist()

outputmd=[]
n_steps=60
i=0
while(i<30):
  if(len(temp_inputmd)>60):
    x_inputmd=np.array(temp_inputmd[1:])
    x_inputmd=x_inputmd.reshape(1,-1)
    x_inputmd=x_inputmd.reshape(1,n_steps,1)
    ynewmd =modelmd.predict(x_inputmd,verbose=0)
    temp_inputmd.extend(ynewmd[0].tolist())
    temp_inputmd=temp_inputmd[1:]
    outputmd.extend(ynewmd.tolist())
    i=i+1
  else:
    x_inputmd=x_inputmd.reshape(1,n_steps,1)
    ynew=modelmd.predict(x_inputmd,verbose=0)
    temp_inputmd.extend(ynewmd[0].tolist())
    outputmd.extend(ynewmd.tolist())
    i=i+1

outputnv=[]
n_steps=60
p=0
while(p<30):
  if(len(temp_inputnv)>60):
    x_inputnv=np.array(temp_inputnv[1:])
    x_inputnv=x_inputnv.reshape(1,-1)
    x_inputnv=x_inputnv.reshape(1,n_steps,1)
    ynewnv =modelnv.predict(x_inputnv,verbose=0)
    temp_inputnv.extend(ynewnv[0].tolist())
    temp_inputnv=temp_inputnv[1:]
    outputnv.extend(ynewnv.tolist())
    p=p+1
  else:
    x_inputnv=x_inputnv.reshape(1,n_steps,1)
    ynewnv=modelnv.predict(x_inputnv,verbose=0)
    temp_inputnv.extend(ynewnv[0].tolist())
    outputnv.extend(ynewnv.tolist())
    p=p+1

outputinv=[]
n_steps=60
q=0
while(q<30):
  if(len(temp_inputinv)>60):
    x_inputinv=np.array(temp_inputinv[1:])
    x_inputinv=x_inputinv.reshape(1,-1)
    x_inputinv=x_inputinv.reshape(1,n_steps,1)
    ynewinv =modelinv.predict(x_inputinv,verbose=0)
    temp_inputinv.extend(ynewinv[0].tolist())
    temp_inputinv=temp_inputinv[1:]
    outputinv.extend(ynewinv.tolist())
    q=q+1
  else:
    x_inputinv=x_inputinv.reshape(1,n_steps,1)
    ynewinv=modelinv.predict(x_inputinv,verbose=0)
    temp_inputinv.extend(ynewinv[0].tolist())
    outputinv.extend(ynewinv.tolist())
    q=q+1

datanv_new=datanv.tolist()
datainv_new=datainv.tolist()
datamd_new=datamd.tolist()
prednv=datanv_new.extend(outputnv)
predinv=datainv_new.extend(outputinv)
predmd=datamd_new.extend(outputmd)

plt.title('PREDICTED VALUES')
plt.xlabel('DATE -->',fontsize = 20)
plt.ylabel('PRICE -->',fontsize = 20)
plt.plot(datamd_new,label='Moderna')
plt.plot(datanv_new,label='Novavax')
plt.plot(datainv_new,label='Invio')
plt.plot(predmd,label='Predicted_Moderna')
plt.plot(prednv,label='Predicted_Novavax')
plt.plot(predinv,label='Predicted_Invio')
plt.legend()